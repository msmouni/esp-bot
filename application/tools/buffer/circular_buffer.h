#ifndef TOOLS_CIRCULAR_BUFFER
#define TOOLS_CIRCULAR_BUFFER

#include <stdint.h>
#include <mutex>
#include <memory>
#include "additional.h"

using namespace additional::option;

// https://embeddedartistry.com/blog/2017/05/17/creating-a-circular-buffer-in-c-and-c/
template <class T, uint8_t Capacity>
class CircularBuffer
{
private:
    std::mutex m_mutex = {};
    std::unique_ptr<T[]> m_data;
    uint8_t m_head;
    uint8_t m_tail;
    uint8_t m_nb_element;

public:
    CircularBuffer() : m_data(std::unique_ptr<T[]>(new T[Capacity])), m_head(0), m_tail(0), m_nb_element(0) {}
    /*
        The default copy constructor generated by the compiler copies all data members by default. The std::mutex isn't copyable.

        You can write your own copy constructor that doesn't attempt to copy the mutex or simply delete the copy constructor.
    */
    CircularBuffer(const CircularBuffer &) = delete;
    CircularBuffer &operator=(const CircularBuffer &) = delete;

    bool push(const T element)
    {
        std::lock_guard<std::mutex> lock(m_mutex);

        if (isFull())
        {
            return false;
        }
        else
        {
            m_data[m_tail] = element;
            m_nb_element++;
            m_tail++;
            if (m_tail == Capacity)
            {
                m_tail = 0;
            }
            return true;
        }
    }
    // NOTE: A COPY OF T is made here: (In the case of ServerFrame<LEN> ... Stackoverflow)
    //       if using Refs: Refs must always point to data
    //       Maybe try to use pointers (store data in buffer, but return only a pointer to data(dangling pointer))
    Option<T> get()
    {
        std::lock_guard<std::mutex> lock(m_mutex);

        if (isEmpty())
        {
            return Option<T>();
        }
        else
        {
            Option<T> result = Option<T>(m_data[m_head]);
            m_nb_element--;
            m_head++;
            if (m_head == Capacity)
            {
                m_head = 0;
            }
            return result;
        }
    }
    // Note: Constant member functions are those functions that are denied permission to change the values of the data members of their class.
    constexpr uint8_t capacity() const { return Capacity; }
    uint8_t size() const
    {
        std::lock_guard<std::mutex> lock(m_mutex);
        return m_nb_element;
    }
    bool isFull() const
    {
        return m_nb_element == Capacity;
    }
    bool isEmpty() const
    {
        return m_nb_element == 0;
    }
};
#endif // TOOLS_CIRCULAR_BUFFER